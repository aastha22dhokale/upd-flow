Nice — we’re implementing compare → soft-close → create only inside UpdateOrganisationUnitService and adding only the minimal repository + payload helpers needed. No extra files, no changes outside your project structure.

Below are the full, ready-to-paste updated files. I kept style, imports and error handling consistent with your project.

⸻

1) UpdateOrganisationUnitService.java

Replace the postal-address blocks in this file with the implementation below. It keeps the existing name/digital logic untouched and adds a single compare method (one method compares all postal fields) and the orchestration (soft-close → create).

package com.ing.datadist.api.service;

import com.ing.datadist.api.model.*;
import com.ing.datadist.domain.OrganisationUnitDomainWrapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.lang.NonNull;
import com.ing.datadist.api.payload.PayloadFactory;

import java.util.List;
import java.util.Objects;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j
public class UpdateOrganisationUnitService {
    private final OnePamRepository onePamRepository;
    private static final String POSTAL_USAGE_TYPE = "RSDNT_ADR";

    public UpdateOrganisationUnitService(OnePamRepository onePamRepository){
        this.onePamRepository = onePamRepository;
    }

    public void updateOrganisationUnit(OrganisationUnitDomainWrapper wrapper,
                                       SearchInvolvedPartiesResponseV1 response,
                                       @NonNull Boolean apiFlag) throws Exception {
        String uuid = wrapper.getOpsUUID();
        List<SearchOrganisationUnitResponseV1> organisationUnits = response.getOrganisationUnits();
        for (SearchOrganisationUnitResponseV1 organisationUnit : organisationUnits) {
            List<SearchOrganisationUnitNameResponseV1> organisationUnitNames = organisationUnit.getOrganisationUnitNames();
            List<SearchOrganisationUnitAddressResponseV1> postalAddresses = organisationUnit.getPostalAddresses();
            List<SearchOrganisationUnitDigitalAddressesV1> digitalAddresses = organisationUnit.getDigitalAddresses();

            // --- existing name logic (unchanged) ---
            for (SearchOrganisationUnitNameResponseV1 name : organisationUnitNames) {
                if (Objects.equals(wrapper.getOrganisationUnitName(), name.getOrganisationUnitName())) {
                    log.info("Update organisationUnit name changed for uuid:{}  old:{} new:{}  ",
                            uuid, wrapper.getOrganisationUnitName(), name.getOrganisationUnitName());
                    if(apiFlag){
                        UpdateOrganisationUnitNameV5Request payload =
                                PayloadFactory.buildUpdateNamePayload(wrapper, wrapper.getOrganisationUnitName());
                        onePamRepository.updateOrganisationUnitName(payload, uuid, "DD");
                    }
                }
            }

            // --- NEW: postal compare -> soft-close -> create (all in one place) ---
            for (SearchOrganisationUnitAddressResponseV1 address : postalAddresses) {
                // Compare all postal fields in a single method
                boolean changed = isPostalAddressChanged(address, wrapper);
                if (changed) {
                    log.info("Postal address change detected for uuid:{} - proceeding with soft-close + create", uuid);
                    if (apiFlag) {
                        try {
                            // Soft-close existing postal address (POST .../close)
                            onePamRepository.closePostalAddress(uuid, POSTAL_USAGE_TYPE).get();

                            // Build create payload from wrapper and call create
                            CreatePostalAddressRequest createPayload = PayloadFactory.buildCreatePostalPayload(wrapper);
                            onePamRepository.createPostalAddress(uuid, createPayload).get();

                            log.info("Postal address updated (soft-closed old, created new) for uuid: {}", uuid);
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            log.error("Interrupted while updating postal address for uuid {}", uuid, ie);
                            throw ie;
                        } catch (ExecutionException ee) {
                            log.error("Execution exception during postal address update for uuid {}", uuid, ee);
                            throw new RuntimeException("Postal address update failed", ee);
                        }
                    } else {
                        log.info("apiFlag is false — skipping actual postal API calls for uuid {}", uuid);
                    }
                } else {
                    log.info("No postal address change for uuid:{} - skipping", uuid);
                }
            }

            // --- existing digital logic (unchanged) ---
            for (SearchOrganisationUnitDigitalAddressesV1 digitalAddress : digitalAddresses) {
                if (Objects.equals(wrapper.getDigitalAddrEmail(), digitalAddress.getFullDigitalAddress())) {
                    log.info("Update organisationUnit FullDigitalAddress changed for uuid:{}  old:{} new:{} ",
                            uuid, wrapper.getDigitalAddrEmail(), digitalAddress.getFullDigitalAddress());
                    if(apiFlag){
                        UpdateDigitalAddressV5Request payload =
                                PayloadFactory.buildUpdateDigitalPayload(wrapper);
                        onePamRepository.updateDigitalAddress(payload, uuid, "DD");
                    }
                }
            }
        }
    }

    /**
     * Single comparison method for postal address — compares the significant fields.
     * Returns true if any field differs (i.e. update needed).
     */
    private boolean isPostalAddressChanged(SearchOrganisationUnitAddressResponseV1 existing,
                                           OrganisationUnitDomainWrapper incomingWrapper) {
        if (existing == null) return true;

        // Compare a comprehensive set of fields. Add/remove fields according to mapping.
        if (!Objects.equals(existing.getStreetName(), incomingWrapper.getPostalAddressStreetNm())) return true;
        if (!Objects.equals(existing.getHouseNumber(), incomingWrapper.getPostalAddressHouseNum())) return true;
        if (!Objects.equals(existing.getHouseNumberAddition(), incomingWrapper.getPostalAddressHouseAdd())) return true;
        if (!Objects.equals(existing.getPostalCode(), incomingWrapper.getPostalAddressPostalCd())) return true;
        if (!Objects.equals(existing.getCityName(), incomingWrapper.getPostalAddressCityName())) return true;
        if (!Objects.equals(existing.getCountryCode(), incomingWrapper.getPostalAddressCntryCd())) return true;
        if (!Objects.equals(existing.getBuildingName(), incomingWrapper.getPostalAddressBuildingNm())) return true; // if wrapper has it
        if (!Objects.equals(existing.getUnstructuredAddressLine1(), incomingWrapper.getPostalAddressUnstructured1())) return true;
        if (!Objects.equals(existing.getUnstructuredAddressLine2(), incomingWrapper.getPostalAddressUnstructured2())) return true;
        if (!Objects.equals(existing.getUnstructuredAddressLine3(), incomingWrapper.getPostalAddressUnstructured3())) return true;
        if (!Objects.equals(existing.getDeliveryInformation(), incomingWrapper.getPostalAddressDeliveryInfo())) return true;

        // if reached here, no significant differences
        return false;
    }
}

Notes on this file
	•	It uses the SearchOrganisationUnitAddressResponseV1 existing object (from search response) for comparison — no PATCH GET is called here.
	•	Calls onePamRepository.closePostalAddress(...) and onePamRepository.createPostalAddress(...) and blocks on .get() to ensure sequence.
	•	isPostalAddressChanged(...) is a single method comparing all relevant fields (you can tweak fields later).

⸻

2) OnePamRepository.java

Add the two methods below into your existing OnePamRepository class (paste them into the class with the other API methods). I matched your existing style and exceptions.

    /**
     * Soft-close an active postal address for the given involved-party UUID and usageType.
     * Calls:
     * POST /v5/involved-parties/{uuid}/postal-addresses/{postalAddressUsageType}/close
     */
    public CompletableFuture<Void> closePostalAddress(String uuid, String usageType) {
        try {
            String url = RegkeyEnum.CLOSE_POSTAL_ADDRESS.resolveEndpoint(uuid, usageType);
            log.info("Calling OnePAM API to close postal address for UUID: {} usageType: {}", uuid, usageType);
            Request request = new RichHttpRequestBuilder()
                    .withUrl(url)
                    .withMethod(Method.Post())
                    .withHeader("X-ING-LastUpdateUser", "IN_ADMIN")
                    .build();
            return apiClient.apply(request)
                    .thenApply(response -> {
                        if (response.statusCode() >= 200 && response.statusCode() < 300) {
                            return null;
                        } else {
                            throw new DataDistributionApiException(
                                    RegkeyEnum.CLOSE_POSTAL_ADDRESS,
                                    "Failed to close postal address",
                                    "Status: " + response.statusCode()
                            );
                        }
                    });
        } catch (RichHttpRequestBuilderException e) {
            throw new DataDistributionApiException(
                    RegkeyEnum.CLOSE_POSTAL_ADDRESS,
                    "Failed to build request for close postal address API",
                    e.getMessage()
            );
        }
    }

    /**
     * Create a new postal address for the given involved-party UUID.
     * Calls:
     * POST /v5/involved-parties/{uuid}/postal-addresses
     */
    public CompletableFuture<Void> createPostalAddress(String uuid, CreatePostalAddressRequest payload) {
        try {
            String url = RegkeyEnum.CREATE_POSTAL_ADDRESS.resolveEndpoint(uuid);
            log.info("Calling OnePAM API to create postal address for UUID: {}", uuid);
            Request request = new RichHttpRequestBuilder()
                    .withUrl(url)
                    .withMethod(Method.Post())
                    .withJsonContent(payload)
                    .withHeader("X-ING-LastUpdateUser", "IN_ADMIN")
                    .build();
            return apiClient.apply(request)
                    .thenApply(response -> {
                        if (response.statusCode() >= 200 && response.statusCode() < 300) {
                            log.info("Postal address created successfully for UUID: {}", uuid);
                            return null;
                        } else {
                            log.error("Failed to create postal address. Status: {}", response.statusCode());
                            throw new DataDistributionApiException(
                                    RegkeyEnum.CREATE_POSTAL_ADDRESS,
                                    "Failed to create postal address",
                                    "Status: " + response.statusCode()
                            );
                        }
                    });
        } catch (RichHttpRequestBuilderException e) {
            throw new DataDistributionApiException(
                    RegkeyEnum.CREATE_POSTAL_ADDRESS,
                    "Failed to build request for postal address creation",
                    e.getMessage()
            );
        }
    }

Notes
	•	I intentionally return CompletableFuture<Void> to match the pattern used elsewhere (you can change to return response DTO if you prefer).
	•	Methods use RegkeyEnum’s resolveEndpoint(...) to build URLs.

⸻

3) PayloadFactory.java

Add a method to build CreatePostalAddressRequest from the OrganisationUnitDomainWrapper. Paste this into your existing PayloadFactory class (you already have other payload builders there).

    public static CreatePostalAddressRequest buildCreatePostalPayload(OrganisationUnitDomainWrapper wrapper) {
        return CreatePostalAddressRequest.builder()
                .postalAddressUsageType("RSDNT_ADR")
                .countryCode(wrapper.getPostalAddressCntryCd())
                .cityName(wrapper.getPostalAddressCityName())
                .streetName(wrapper.getPostalAddressStreetNm())
                .houseNumber(wrapper.getPostalAddressHouseNum())
                .houseNumberAddition(wrapper.getPostalAddressHouseAdd())
                .postalCode(wrapper.getPostalAddressPostalCd())
                .dataSource(wrapper.getRecordActionType() != null ? wrapper.getRecordActionType() : DATA_SOURCE)
                .effectiveDate(java.time.ZonedDateTime.now().format(java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME))
                .endDate(java.time.ZonedDateTime.now().plusYears(10).format(java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME))
                .build();
    }

Notes
	•	It uses DATA_SOURCE (you already import it somewhere else — if not, add import static com.ing.datadist.api.utils.DataDistributionConstants.DATA_SOURCE; at top of PayloadFactory).
	•	You can tweak which wrapper fields map to which postal fields later.

⸻

4) RegkeyEnum.java update

Add the CLOSE_POSTAL_ADDRESS entry if it’s not already present (paste into your enum list):

    CLOSE_POSTAL_ADDRESS("CLOSE_POSTAL_ADDRESS", HttpMethod.POST, "https://api.ing.com/v5/involved-parties/{uuid}/postal-addresses/{postalAddressUsageType}/close"),

You already have CREATE_POSTAL_ADDRESS and UPDATE_POSTAL_ADDRESS so keep them.

⸻

Final notes & how to paste safely
	1.	Update UpdateOrganisationUnitService.java — replace the current file content with the first code block (or insert the postal block into your existing method where postal logic belongs). Keep other logic intact.
	2.	Add the two new methods into OnePamRepository.java — place them alongside the other API methods.
	3.	Add buildCreatePostalPayload(...) into PayloadFactory.java.
	4.	Add CLOSE_POSTAL_ADDRESS in RegkeyEnum (if missing).

This implements compare → soft-close → create inside UpdateOrganisationUnitService, uses constant RSDNT_ADR, and only touches the files you already have.

⸻

If you want I can now:
	•	produce the exact diff for each file (so you can apply patches),
	•	or generate unit-test stubs for the postal flow,
	•	or adjust the compare method fields to match any additional wrapper fields you have (you gave many getter names — I used representative ones; if any getter names differ, paste the exact wrapper getters and I’ll fix them).

Which would you like next?
